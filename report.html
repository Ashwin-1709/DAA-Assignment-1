<h1 id="problem-statement">Problem statement</h1>
<p>Given an arbitrary polygon, decompose it into a set of convex polygons. We have been given the following paper to implement: Algorithms for the decomposition of a polygon into convex polygons, European Journal of Operational Research, 121(2), 330-342. The paper describes three different algorithms for the decomposition of the polygon, we have implement the <span class="math inline"><em>M</em><em>P</em>1</span> algorithm as part of this assignment as well as the merging part that follows.</p>
<h1 id="dcel-doubly-connected-edge-list">DCEL: Doubly Connected Edge List</h1>
<p>We have used the DCEL data structure to store our decomposed polygon. DCEL consists of three main sub-data-structures, namely Vertex, Edge and Face.</p>
<p><img src="./DCEL:_Doubly_Connected_Edge_List/2023-03-06_23-38-16_screenshot.png" /></p>
<p><img src="./DCEL:_Doubly_Connected_Edge_List/2023-03-06_23-37-13_screenshot.png" /></p>
<p>(Images taken from <a href="https://www2.cs.sfu.ca/~binay/813.2011/DCEL.pdf">https://www2.cs.sfu.ca/~binay/813.2011/DCEL.pdf</a>)</p>
<h2 id="polygon">Polygon</h2>
<p>A decomposed polygon is represented by the Polygon class, which contains a list of vertices of the original polygon in clockwise order, and two Faces which represent the outer and inner faces of the initial, undecomposed polygon.</p>
<h2 id="vertex">Vertex</h2>
<p>A vertex contains the coordinates of the point and an IncidentEdge - an edge which originates at the vertex.</p>
<h2 id="edge">Edge</h2>
<p>An edge contains</p>
<ul>
<li>A pointer to its twin (edge with the source and destination swapped)</li>
<li>A pointer to its source vertex (called <code>origin</code>)</li>
<li>A pointer to the face on its left</li>
<li>Pointers to its previous and next edges</li>
</ul>
<h2 id="face">Face</h2>
<p>A face contains a pointer to any one of the representative edges of the face (if we know one edge we can find all of them by traversing using the <code>next</code> field of the edge)</p>
<h1 id="decomposition">Decomposition</h1>
<h2 id="terminology">Terminology</h2>
<h3 id="notch">Notch</h3>
<p>Angle between 3 points <span class="math inline"><em>a</em>,‚ÄÜ<em>b</em>,‚ÄÜ<em>c</em></span> is said to be a notch if it is greater than <span class="math inline">$180 \degree$</span></p>
<h3 id="lpvs">LPVS</h3>
<p><span class="math inline"><em>L</em><em>P</em><em>V</em><em>S</em>(<em>P</em>,‚ÄÜ<em>S</em>)</span> is the list of notches enclosed in <span class="math inline"><em>P</em>‚ÄÖ\‚ÄÖ<em>L</em></span></p>
<h3 id="vtr">VTR</h3>
<p>Intermediate polygon from which we need to remove</p>
<ul>
<li>Notches</li>
<li>Points lying to the right side of the semiplane formed by the notches and the first point of the initial polygon are to be removed.</li>
</ul>
<h2 id="algorithm">Algorithm</h2>
<p>The algorithm relies on successive adding of vertices until the polygon formed by the vertices is not convex. When we cannot add any points to the polygon, we check if any notches are enclosed in the rectangle of minimum area formed by the points added so far. If no notches are present, we create a new polygon by splitting the face of the existing polygon and continue to work on the other half of the newly formed polygon until the number of vertices in our list falls below or equal to - this is the halting condition of the decomposition algorithm. If, in intermediate stages, we notice that notches are present in the rectangle, we remove the notches and the last point of the polygon until we reach a condition where the diagonal formed by the first and the last point does not enclose any other point. We start from the next vertex if we cannot make the polygon.</p>
<h2 id="time-complexity-analysis-of-helper-functions">Time complexity analysis of helper functions</h2>
<h3 id="angleabc-given-three-vertices-find-the-angle-between-them"><code>angle(a,b,c)</code>: Given three vertices, find the angle between them</h3>
<p>Returns the angle swept by line segment <span class="math inline"><em>b</em><em>a</em></span> over <span class="math inline"><em>b</em><em>c</em></span> counterclockwise. For finding the angle, we calculate the magnitudes of <span class="math inline">$\vec{ba}$</span> and <span class="math inline">$\vec{bc}$</span>, and their dot and cross products. We then return different values depending on the sign of the dot and cross products. The time complexity if <span class="math inline">ùí™(1)</span></p>
<h3 id="get_notches-given-a-polygon-return-a-list-of-notches"><code>get_notches</code>: Given a polygon, return a list of notches</h3>
<p>We iterate over the vertices of the polygon in clockwise order, checking if the angle <span class="math inline"><em>v</em><sub><em>i</em>‚ÄÖ‚àí‚ÄÖ1</sub>,‚ÄÜ<em>v</em><sub><em>i</em></sub>,‚ÄÜ<em>v</em><sub><em>i</em>‚ÄÖ+‚ÄÖ1</sub></span> (where <span class="math inline"><em>v</em><sub><em>i</em></sub></span> is the current vertex) is reflex. If the angle is reflex, we add it to the list of notches. Finding the angle takes constant time, hence the time complexity for getting all the notches is <span class="math inline">ùí™(<em>n</em>)</span> where <span class="math inline"><em>n</em></span> is the number of vertices in the polygon.</p>
<h3 id="split_face-given-a-diagonal-and-a-face-split-the-face-at-the-diagonal"><code>split_face</code>: Given a diagonal and a face, split the face at the diagonal</h3>
<p>We iterate over the edges of the face and get the neighbouring edges incident to the diagonal vertices. We do the necessary updates to the <code>next</code> and <code>previous</code> of all the necessary edges. We then create a new face and update its edges so that their left face points to this face. Finally, we return the newly formed face. The time complexity for this process is <span class="math inline">ùí™(<em>n</em>)</span> where <span class="math inline"><em>n</em></span> is the number of vertices in the polygon due to the linear nature of both the processes.</p>
<h3 id="merge_face-given-two-faces-merge-and-return-their-combination"><code>merge_face</code>: Given two faces, merge and return their combination</h3>
<p>We iterate over edges of the first face to find the diagonal between the two faces and perform the necessary updates in the edges. After updation, the left faces of all the edges are updated to the first face and the first face is returned. The time complexity is <span class="math inline">ùí™(<em>n</em>)</span> where <span class="math inline"><em>n</em></span> is the number of vertices in the polygon.</p>
<h3 id="get_lpvs-given-a-list-of-notches-find-the-ones-in-the-polygon-made-by-points-in-p-setminus-l_m"><code>get_LPVS</code>: Given a list of notches, find the ones in the polygon made by points in <span class="math inline"><em>P</em>‚ÄÖ\‚ÄÖ<em>L</em><sub><em>m</em></sub></span></h3>
<p>We iterate over all the notches, and check whether they are present in the list <span class="math inline"><em>L</em><sub><em>m</em></sub></span> (the polygon being made in the <span class="math inline"><em>m</em><sup><em>t</em><em>h</em></sup></span> iteration) and not in <span class="math inline"><em>P</em></span> (the undecomposed polygon we are currently working on). The time complexity is <span class="math inline">ùí™(<em>n</em><sup>2</sup>)</span> as we have to iterate over <span class="math inline"><em>L</em><sub><em>m</em></sub></span> and <span class="math inline"><em>P</em></span> for every notch.</p>
<h3 id="inside_polygon-check-whether-a-point-lies-inside-a-polygon"><code>inside_polygon</code>: Check whether a point lies inside a polygon</h3>
<p>We iterate over the edges in clockwise order. Every time we find an edge one of whose endpoints is above the given point and the other below, and the point is to the right of the edge, we flip a boolean flag. This can be done in <span class="math inline">ùí™(<em>n</em>)</span></p>
<h1 id="merging">Merging</h1>
<h2 id="terminology-1">Terminology</h2>
<h3 id="ldp">LDP</h3>
<p>LDP is an ordered list of boolean flags, <span class="math inline"><em>L</em><em>D</em><em>P</em>[<em>i</em>]‚ÄÑ=‚ÄÑ<em>t</em><em>r</em><em>u</em><em>e</em></span> means that the polygon with index <span class="math inline"><em>i</em></span> is one of the definitive polygons of the partition after the merging process.</p>
<h3 id="lup">LUP</h3>
<p>LUP is an ordered list of integers, <span class="math inline"><em>L</em><em>U</em><em>P</em>[<em>i</em>]‚ÄÑ=‚ÄÑ<em>j</em></span> means that the polygon with index <span class="math inline"><em>i</em></span> is part of the polygon with index <span class="math inline"><em>j</em></span>.</p>
<h3 id="lle">LLE</h3>
<p>LLE is a list containing the diagonals of the partition.</p>
<h2 id="algorithm-1">Algorithm</h2>
<p>We iterate over the list of diagonals (i.e. LLE) and check whether removing the diagonal between two faces does not disturb the convexity of the structure. If it does not, then we merge the two faces and update the LDP and LUP lists.</p>
<h1 id="benchmarks-and-results">Benchmarks and Results</h1>
